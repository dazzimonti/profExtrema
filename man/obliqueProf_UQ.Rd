% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/obliqueProf_UQ.R
\name{obliqueProf_UQ}
\alias{obliqueProf_UQ}
\title{Oblique profiles UQ from a kriging model}
\usage{
obliqueProf_UQ(object, allPhi, threshold, allResMean = NULL,
  quantiles_uq = c(0.05, 0.95), options_approx = NULL,
  options_full_sims = NULL, options_sims = NULL, options_bound = NULL,
  plot_level = 0, plot_options = NULL, return_level = 1)
}
\arguments{
\item{object}{either a \link[DiceKriging]{km} model or a list containing partial results. If \code{object} is a km model then all computations are carried out. If \code{object} is a list, then the function carries out all computations to complete the results list.}

\item{allPhi}{a list containing the matrices Phi (dim \eqn{pxd}) for which to compute the profile extrema}

\item{threshold}{the threshold of interest}

\item{allResMean}{a list resulting from \code{getProfileExtrema} or \code{approxProfileExtrema} for the profile extrema on the mean. If NULL the median from the observations is plotted}

\item{quantiles_uq}{a vector containing the quantiles to be computed}

\item{options_approx}{an optional list of options for approxProfileExtrema, see \link{approxProfileExtrema} for details.}

\item{options_full_sims}{an optional list of options for getProfileExtrema, see \link{getProfileExtrema} for details. If NULL the full computations are not executed. NOTE: this computations might be very expensive!}

\item{options_sims}{an optional list of options for the posterior simulations.
\itemize{
\item{\code{algorithm:}} string choice of the algorithm to select the simulation points ("A" or "B");
\item{\code{lower:}} \eqn{d} dimensional vector with lower bounds for simulation points;
\item{\code{upper:}} \eqn{d} dimensional vector with upper bounds for simulation points;
\item{\code{batchsize:}} number of simulation points;
\item{\code{optimcontrol:}} list containing the options for optimization;
\item{\code{integcontrol:}} list containing the options for numerical integration of the criterion;
\item{\code{integration.param:}} list containing the integration design, obtained with the function \link[KrigInv]{integration_design}.
}}

\item{options_bound}{an optional list containing \code{beta} the confidence level for the approximation and \code{alpha} the confidence level for the bound. If \code{NULL}, the bound is not computed.}

\item{plot_level}{an integer to select the plots to return (0=no plots, 1=basic plots, 2= all plots)}

\item{plot_options}{an optional list of parameters for plots. Currently available options
\itemize{
\item{\code{save:}}{boolean, if TRUE saves the plots in \code{folderPlots}}
\item{\code{folderPlots:}}{a string containing the destination folder for plots, if \code{save==TRUE} default is \code{./}}
\item{\code{ylim:}}{a matrix \code{coord}x2 containing the ylim for each coordinate.}
\item{\code{titleProf:}}{a string containing the title for the coordinate profile plots}
\item{\code{title2d:}}{a string containing the title for the 2d plots (if the input is 2d)}
\item{\code{coord_names:}}{a \eqn{d}-vector of characters naming the dimensions. If NULL and \code{kmModel} not NULL then it is the names of \code{kmModel@X} otherwise \code{x_1,...,x_d}}
\item{\code{design:}}{a \eqn{dxr} matrix where \eqn{d} is the input dimension and \eqn{r} is the size of the discretization for plots at each dimension}
\item{\code{id_save:}}{a string to be added to the plot file names, useful for serial computations on HPC.}
\item{\code{qq_fill:}}{if TRUE it fills the region between the first 2 quantiles in \code{quantiles_uq}.}
\item{\code{col_CCPthresh_nev:}}{Color palette of dimension \code{num_T} for the colors of the vertical lines delimiting the intersections between the profiles sup and the thresholds}
\item{\code{col_CCPthresh_alw:}}{Color palette of dimension \code{num_T} for the colors of the vertical lines delimiting the intersections between the profiles inf and the thresholds}
\item{\code{col_thresh:}}{Color palette of dimension \code{num_T} for the colors of the thresholds}
}}

\item{return_level}{an integer to select the amount of details returned}
}
\value{
If return_level=1 a list containing \itemize{
\item{\code{profSups:}}{an array \code{dxfullDesignSizexnsims} containing the profile sup for each coordinate for each realization.}
\item{\code{profInfs:}}{an array \code{dxfullDesignSizexnsims} containing the profile inf for each coordinate for each realization.}
\item{\code{prof_quantiles_approx:}}{a list containing the quantiles (levels set by \code{quantiles_uq}) of the profile extrema functions.}
} if return_level=2 the same list as above but also including \code{more:} a list containing \itemize{
\item{\code{times:}}{a list containing
	\itemize{
	\item{\code{tSpts:} }{computational time for selecting simulation points.}
	\item{\code{tApprox1ord:}}{vector containing the computational time required for profile extrema computation for each realization}
	}}
\item{\code{simuls:}}{ a matrix containing the value of the field simulated at the simulation points}
\item{\code{sPts:}}{the simulation points}
}
}
\description{
The function obliqueProf_UQ computes the profile extrema functions for posterior realizations of a Gaussian process and its confidence bounds
}
\examples{
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute a kriging model from 50 evaluations of the Branin function
# Define the function
g<-function(x){
  return(-branin(x))
}
gp_des<-lhs::maximinLHS(20,2)
reals<-apply(gp_des,1,g)
kmModel<-km(design = gp_des,response = reals,covtype = "matern3_2")

threshold=-10
d<-2

# Compute oblique profiles UQ starting from GP model
# define simulation options
options_sims<-list(algorithm="B", lower=rep(0,d), upper=rep(1,d),
                   batchsize=80, optimcontrol = list(method="genoud",pop.size=100,print.level=0),
                   integcontrol = list(distrib="sobol",n.points=1000), nsim=150)
# define approximation options
options_approx<- list(multistart=4,heavyReturn=TRUE,
                      initDesign=NULL,fullDesignSize=100,
                      smoother=NULL)
# define plot options
options_plots<-list(save=FALSE, titleProf = "Coordinate profiles",
                    title2d = "Posterior mean",qq_fill=TRUE)

# Define the oblique directions
# (for theta=0 it is equal to coordinateProfiles)
theta=pi/4
allPhi = list(Phi1=matrix(c(cos(theta),sin(theta)),ncol=2),
              Phi2=matrix(c(cos(theta+pi/2),sin(theta+pi/2)),ncol=2))
\dontrun{
# profile UQ on approximate oblique profiles
oProfiles_UQ<-obliqueProf_UQ(object = kmModel,threshold = threshold,allPhi=allPhi,
                             allResMean = NULL,quantiles_uq = c(0.05,0.95),
                             options_approx = options_approx, options_full_sims = NULL,
                             options_sims = options_sims,options_bound = NULL,
                             plot_level = 3, plot_options = options_plots,return_level = 3)
# profile UQ on full optim oblique profiles

options_full_sims<-list(multistart=4,heavyReturn=TRUE)
options_sims$nsim <- 50
oProfiles_UQ_full<- obliqueProf_UQ(object = oProfiles_UQ,threshold = threshold,allPhi=allPhi,
                             allResMean = NULL,quantiles_uq = c(0.05,0.95),
                             options_approx = options_approx, options_full_sims = options_full_sims,
                             options_sims = options_sims,options_bound = NULL,
                             plot_level = 3, plot_options = options_plots,return_level = 3)



# profile UQ on full optim oblique profiles with bound
oProfiles_UQ_full_bound<-obliqueProf_UQ(object = oProfiles_UQ_full,threshold = threshold,
                                        allPhi=allPhi, allResMean = NULL,
                                        quantiles_uq = c(0.05,0.95),
                                        options_approx = options_approx,
                                        options_full_sims = options_full_sims,
                                      options_sims = options_sims,
                                      options_bound = list(beta=0.055,alpha=0.05),
                                      plot_level = 3, plot_options = options_plots,
                                      return_level = 3)
}
}
\author{
Dario Azzimonti
}
